[{"path":"https://neokok.github.io/wearableAnomaly/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 wearableAnomaly authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":[]},{"path":"https://neokok.github.io/wearableAnomaly/articles/genai-tutorial.html","id":"introduction","dir":"Articles","previous_headings":"GenAI Workflow for wearableAnomaly","what":"Introduction","title":"GenAI Workflow for wearableAnomaly","text":"vignette documents generative AI tools helped build wearableAnomaly package. summarizes prompts, workflows, guardrails used turning Biostat 615 project outline reproducible R package.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/articles/genai-tutorial.html","id":"tools-used","dir":"Articles","previous_headings":"GenAI Workflow for wearableAnomaly","what":"Tools used","title":"GenAI Workflow for wearableAnomaly","text":"ChatGPT: Used plan, summarize goals, write “first prompts”, convert vague goals small, testable tasks. OpenAI Codex Agent VS Code: Used make actual repo changes. Especially useful editing multiple files consistently, adding tests, cleaning packaging details. Copilot Chat: Used similarly Codex smaller edits. key constrain scope one file one task. pkgdown / R CMD check: final validation documentation builds.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/articles/genai-tutorial.html","id":"development-workflow","dir":"Articles","previous_headings":"GenAI Workflow for wearableAnomaly","what":"Development workflow","title":"GenAI Workflow for wearableAnomaly","text":"loop followed start finish.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/articles/genai-tutorial.html","id":"phase-1--plan-before-coding","dir":"Articles","previous_headings":"GenAI Workflow for wearableAnomaly > Development workflow","what":"Phase 1. Plan (before coding)","title":"GenAI Workflow for wearableAnomaly","text":"Define purpose, inputs, outputs, edge cases, invariants. Decide return schema front (column names, types, units).","code":""},{"path":"https://neokok.github.io/wearableAnomaly/articles/genai-tutorial.html","id":"phase-2--implement-scoped-codex-changes","dir":"Articles","previous_headings":"GenAI Workflow for wearableAnomaly > Development workflow","what":"Phase 2. Implement (scoped Codex changes)","title":"GenAI Workflow for wearableAnomaly","text":"Constrain scope 1 file 1 feature. List concrete acceptance criteria (must pass, output must look like). Add update R/Rcpp code. Add update tests alongside code.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/articles/genai-tutorial.html","id":"phase-3--validate-tight-feedback-loop","dir":"Articles","previous_headings":"GenAI Workflow for wearableAnomaly > Development workflow","what":"Phase 3. Validate (tight feedback loop)","title":"GenAI Workflow for wearableAnomaly","text":"devtools::test() devtools::check() changes bigger Bench scripts performance involved Paste failing output, minimal reproduction, expected behavior. Ask smallest fix preserves current API.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/articles/genai-tutorial.html","id":"phase-4--stabilize-the-interface-when-things-get-messy","dir":"Articles","previous_headings":"GenAI Workflow for wearableAnomaly > Development workflow","what":"Phase 4. Stabilize the interface (when things get messy)","title":"GenAI Workflow for wearableAnomaly","text":"outputs internal schemas become hard reason , pause redesign. re-run Phase 2 implement new interface cleanly.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/articles/genai-tutorial.html","id":"phase-5--package-polish-after-code-is-stable","dir":"Articles","previous_headings":"GenAI Workflow for wearableAnomaly > Development workflow","what":"Phase 5. Package polish (after code is stable)","title":"GenAI Workflow for wearableAnomaly","text":"Update README examples run end--end. Write vignettes match final presentation narrative. Update pkgdown navigation story easy follow.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/articles/genai-tutorial.html","id":"step-by-step-examples","dir":"Articles","previous_headings":"GenAI Workflow for wearableAnomaly","what":"Step-by-step examples","title":"GenAI Workflow for wearableAnomaly","text":"section gives concrete examples prompts used asked agent change. example follows pattern. Goal. Prompt. checked locally confirm worked.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/articles/genai-tutorial.html","id":"example-1--create-a-first-prompt-so-the-agent-understands-project-goals","dir":"Articles","previous_headings":"GenAI Workflow for wearableAnomaly > Step-by-step examples","what":"Example 1. Create a “first prompt” so the agent understands project goals","title":"GenAI Workflow for wearableAnomaly","text":"Goal. Codex read slides PDFs directly, used ChatGPT produce reusable “first prompt” captures repo contain “done” means. Prompt (ChatGPT).  validated. “first prompt” listed concrete repo requirements (installability, core functions, documentation, GenAI tutorial). prompt structured paste Codex unchanged.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/articles/genai-tutorial.html","id":"example-2--targeted-readme-edit-high-leverage-low-risk","dir":"Articles","previous_headings":"GenAI Workflow for wearableAnomaly > Step-by-step examples","what":"Example 2. Targeted README edit (high leverage, low risk)","title":"GenAI Workflow for wearableAnomaly","text":"Goal. Make README match real exported functions include runnable quickstart example. Prompt (ChatGPT -> Codex).  validated. README examples run clean session. function list README matches NAMESPACE exports. unrelated files changed.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/articles/genai-tutorial.html","id":"example-2b--capture-the-result-as-evidence-agent-confirmation","dir":"Articles","previous_headings":"GenAI Workflow for wearableAnomaly > Step-by-step examples","what":"Example 2b. Capture the result as evidence (agent confirmation)","title":"GenAI Workflow for wearableAnomaly","text":"Goal. Save clear “moving ” checkpoint README work actually landed. Evidence (Codex output).  validated. - change described output matches see README.md. - Running README quickstart works locally.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/articles/genai-tutorial.html","id":"example-2c--turn-the-checkpoint-into-the-next-targeted-prompt","dir":"Articles","previous_headings":"GenAI Workflow for wearableAnomaly > Step-by-step examples","what":"Example 2c. Turn the checkpoint into the next targeted prompt","title":"GenAI Workflow for wearableAnomaly","text":"Goal. README aligned, ask ChatGPT next prompt targets next step cleanup plan. Prompt (ChatGPT).  validated. - suggested next prompt scoped one task. - moved project forward without reopening whole repo plan.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/articles/genai-tutorial.html","id":"example-3--read-only-redundancy-audit-before-cleanup","dir":"Articles","previous_headings":"GenAI Workflow for wearableAnomaly > Step-by-step examples","what":"Example 3. Read-only redundancy audit before cleanup","title":"GenAI Workflow for wearableAnomaly","text":"Goal. Identify redundant confusing files removed clearly quarantined, without making changes yet. Prompt (ChatGPT -> Codex).  validated. output produced concrete “keep vs drop” list. recommendations easy convert small cleanup tasks.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/articles/genai-tutorial.html","id":"guardrails-i-used","dir":"Articles","previous_headings":"GenAI Workflow for wearableAnomaly","what":"Guardrails I used","title":"GenAI Workflow for wearableAnomaly","text":"rules helped keep changes safe made easier debug. Keep scope small. One file one feature per prompt. Require acceptance criteria. Always specify success looks like. Always run tests changes. Prefer minimal fixes rewrites. behavior ambiguous, pause redesign interface adding code.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/articles/genai-tutorial.html","id":"what-worked-well","dir":"Articles","previous_headings":"GenAI Workflow for wearableAnomaly","what":"What worked well","title":"GenAI Workflow for wearableAnomaly","text":"Scaffolding consistency. ChatGPT good turning high-level outline coherent package plan (function names, responsibilities, pieces connect). reduced early “design churn” made later implementation systematic. Small, scoped edits. Codex performed best constrained task one file one feature gave explicit acceptance criteria (expected columns, return types, edge cases, tests pass). Documentation acceleration. Drafting README vignette structure fast, easy iterate wording organization filling details. Boilerplate generation. Rcpp skeletons, roxygen templates, initial test scaffolds high value repetitive, still require consistent formatting naming. Debugging evidence. supplied failing outputs minimal reproduction, Codex often found precise fix quickly, especially small --one errors, missing imports/exports, documentation mismatches.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/articles/genai-tutorial.html","id":"what-didnt-work-well","dir":"Articles","previous_headings":"GenAI Workflow for wearableAnomaly","what":"What didn’t work well","title":"GenAI Workflow for wearableAnomaly","text":"Ambiguity amplified quickly. specify schema details (column names, units, types), Codex frequently guessed incorrectly. common failures unit mismatches (seconds vs minutes), inconsistent column naming, small differences intended return structure. Complex internal data structures. Nested tibbles list-columns error-prone agent. Even code “worked”, outputs sometimes awkward consume, forced API redesign step. Long prompts broad scope. Multi-file refactors single prompt often led partial updates (tests updated, docs drifting exports, helper functions invented wired ). Methods logic still needed human control. changepoint details statistical design decisions (e.g., penalty choices, energy-distance variants), GenAI useful implementation ideas structure, still define correct approach verify behavior carefully.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/articles/genai-tutorial.html","id":"validation-strategy","dir":"Articles","previous_headings":"GenAI Workflow for wearableAnomaly","what":"Validation strategy","title":"GenAI Workflow for wearableAnomaly","text":"Unit tests: ran tests/testthat/ major change; many Codex-generated snippets failed initially required re-prompts. Comparator benchmarks: compared wearableAnomaly PELT/E-divisive changepoint {ecp} (installed) using bench scripts evaluate_methods. Visual inspection: used workflow vignette’s episode tables + overlay plot verify detectors/changepoints. pkgdown/site builds: forced pkgdown::build_site() ensure documentation matched exported API.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/articles/genai-tutorial.html","id":"lessons-learned-advice","dir":"Articles","previous_headings":"GenAI Workflow for wearableAnomaly","what":"Lessons learned / advice","title":"GenAI Workflow for wearableAnomaly","text":"Start mini-spec, code. Write purpose, inputs, outputs, invariants, concrete return schema first. prompt. best way prevent “almost-right” implementations. Make prompts test-driven. non-trivial change, included acceptance criteria like “add tests fail change pass ” “run devtools::test() editing”. kept work grounded. Keep scope intentionally small. One file one feature per prompt dramatically easier validate debug broad refactor. Always provide evidence debugging. effective debugging prompts included failing test output, minimal reproduction, exact expected behavior. reliably produced smaller, safer fixes. Use GenAI speed, authority. excelled scaffolding, repetitive edits, drafting documentation, treated outputs drafts tests, benchmarks, end--end examples confirmed behavior. Pause redesign interface gets confusing. output schema became hard explain use, worth stopping simplify API instead piling patches.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/articles/rcpp-comparison.html","id":"motivation","dir":"Articles","previous_headings":"","what":"Motivation","title":"Comparing R and Rcpp Implementations","text":"wearableAnomaly ships R Rcpp implementations computationally intensive routines. default, package selects native code path shared library available, can switch back pure R parity teaching purposes. vignette illustrates: PELT vs. reference changepoint implementation. E-divisive vs. {ecp}. toggle R Rcpp backends benchmark . Note: Comparator packages optional. Install beforehand run chunks marked eval = FALSE.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/articles/rcpp-comparison.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Comparing R and Rcpp Implementations","text":"","code":"library(wearableAnomaly) library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union set.seed(20251118) series <- toy_cgm(n_id = 1, n = 300, by = \"5 min\") ts <- as_wearable_ts(series, id = id, time = time, value = value)"},{"path":"https://neokok.github.io/wearableAnomaly/articles/rcpp-comparison.html","id":"toggling-the-backend","dir":"Articles","previous_headings":"","what":"Toggling the backend","title":"Comparing R and Rcpp Implementations","text":"Two options control backend selection: Setting wearableAnomaly.use_rcpp = FALSE forces pure R fallback, useful debugging machines without compilers.","code":"options(   wearableAnomaly.use_rcpp = TRUE,     # enable/disable native code   wearableAnomaly.rcpp_threshold = 1L  # minimum n to trigger native path )"},{"path":"https://neokok.github.io/wearableAnomaly/articles/rcpp-comparison.html","id":"pelt-vs-changepoint","dir":"Articles","previous_headings":"","what":"PELT vs {changepoint}","title":"Comparing R and Rcpp Implementations","text":"","code":"library(changepoint) pelt_pkg <- detect_changepoints_pelt(ts, min_seg_len = 15, penalty = \"MBIC\") cpt_pkg  <- changepoint::cpt.meanvar(ts$value, method = \"PELT\", penalty = \"MBIC\", minseglen = 15)  all.equal(pelt_pkg$cp_index, changepoint::cpts(cpt_pkg))"},{"path":"https://neokok.github.io/wearableAnomaly/articles/rcpp-comparison.html","id":"benchmark-optional","dir":"Articles","previous_headings":"PELT vs {changepoint}","what":"Benchmark (optional)","title":"Comparing R and Rcpp Implementations","text":"Rcpp core (src/pelt_core.cpp) uses prefix sums pruning match reference algorithm’s accuracy reducing allocations loop overhead.","code":"library(bench) bench::mark(   wearable = detect_changepoints_pelt(ts, min_seg_len = 15),   changepoint = changepoint::cpt.meanvar(ts$value, method = \"PELT\", penalty = \"MBIC\", minseglen = 15),   iterations = 5 )"},{"path":"https://neokok.github.io/wearableAnomaly/articles/rcpp-comparison.html","id":"e-divisive-vs-ecp","dir":"Articles","previous_headings":"","what":"E-divisive vs {ecp}","title":"Comparing R and Rcpp Implementations","text":"","code":"library(ecp) ediv_pkg <- detect_changepoints_edivisive(ts, min_seg_len = 20, R = 199) ecp_pkg  <- ecp::e.divisive(matrix(ts$value, ncol = 1), sig.lvl = 0.05, R = 199, beta = 0.1) ecp_cpts <- ecps_pkg$estimates[-c(1, length(ecp_pkg$estimates))]  match_idx <- match(ediv_pkg$cp_index, ecp_cpts) all(!is.na(match_idx))"},{"path":"https://neokok.github.io/wearableAnomaly/articles/rcpp-comparison.html","id":"benchmark-optional-1","dir":"Articles","previous_headings":"E-divisive vs {ecp}","what":"Benchmark (optional)","title":"Comparing R and Rcpp Implementations","text":"Rcpp helper (energy_stat_segment()) precomputes pairwise distances reuses permutation tests, resulting substantial runtime savings matching {ecp} across seeds.","code":"bench::mark(   wearable = detect_changepoints_edivisive(ts, min_seg_len = 20, R = 99),   ecp = ecp::e.divisive(matrix(ts$value, ncol = 1), sig.lvl = 0.05, R = 99, beta = 0.05),   iterations = 3 )"},{"path":"https://neokok.github.io/wearableAnomaly/articles/rcpp-comparison.html","id":"inspecting-backend-choice","dir":"Articles","previous_headings":"","what":"Inspecting backend choice","title":"Comparing R and Rcpp Implementations","text":"can confirm path active exported helper: FALSE, ensure package compiled (R CMD INSTALL .), set wearableAnomaly.use_rcpp = FALSE avoid warnings machines without build tools.","code":"wearableAnomaly::: .ed_cpp_available() #> [1] TRUE"},{"path":"https://neokok.github.io/wearableAnomaly/articles/rcpp-comparison.html","id":"reproducing-the-tests","dir":"Articles","previous_headings":"","what":"Reproducing the tests","title":"Comparing R and Rcpp Implementations","text":"parity timing tests used development live tests/testthat/test_pelt.R tests/testthat/test_edivisive.R. Run directly : automatically skip changepoint, {ecp}, Rcpp backend unavailable.","code":"devtools::test(filter = \"pelt|edivisive\")"},{"path":"https://neokok.github.io/wearableAnomaly/articles/workflow.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"End-to-End Wearable Anomaly Workflow","text":"wearableAnomaly delivers batch anomaly-detection pipeline single-sensor signals continuous glucose monitors (CGMs). vignette walks tidy workflow: ingesting raw observations, validating/resampling, running artifact changepoint detectors (Rcpp acceleration enabled default), merging/scoring segments, evaluating precision/recall labeled episodes.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/articles/workflow.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting started","title":"End-to-End Wearable Anomaly Workflow","text":"illustration generate two synthetic subjects structured meals noise:","code":"library(wearableAnomaly) library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union library(ggplot2) set.seed(20251117) raw <- toy_cgm(n_id = 2, n = 240, by = \"5 min\") glimpse(raw) #> Rows: 480 #> Columns: 3 #> $ id    <chr> \"id01\", \"id01\", \"id01\", \"id01\", \"id01\", \"id01\", \"id01\", \"id01\", … #> $ time  <dttm> 2025-01-01 00:00:00, 2025-01-01 00:05:00, 2025-01-01 00:10:00, … #> $ value <dbl> 107, 112, 107, 120, 114, 109, 116, 118, 118, 114, 123, 118, 114,…"},{"path":"https://neokok.github.io/wearableAnomaly/articles/workflow.html","id":"ingest-and-validate","dir":"Articles","previous_headings":"","what":"Ingest and validate","title":"End-to-End Wearable Anomaly Workflow","text":"as_wearable_ts() enforces <id, time, value> schema stores cadence, bounds, timezone metadata. validate_ts() reports ordering, duplicates, range issues; use has_issues() gate downstream processing. problems exist summarized issues.","code":"ts <- as_wearable_ts(raw, id = id, time = time, value = value) issues <- validate_ts(ts) has_issues(issues) #> [1] FALSE"},{"path":"https://neokok.github.io/wearableAnomaly/articles/workflow.html","id":"resample-and-detect-artifacts","dir":"Articles","previous_headings":"","what":"Resample and detect artifacts","title":"End-to-End Wearable Anomaly Workflow","text":"Irregularly sampled devices can regularized resample_series(). artifact detectors operate resampled tibble: detector produces tidy episodes (id, start, end, type, strength) can plotted exported independently.","code":"ts_5min <- resample_series(ts, by = \"5 min\", agg = \"mean\") flat <- detect_flatlines(ts_5min, tol = 2, min_len = \"20 min\") sat  <- detect_saturation(ts_5min, min_len = \"15 min\") roc  <- detect_rate_change(ts_5min, window = \"20 min\", threshold = 3)"},{"path":"https://neokok.github.io/wearableAnomaly/articles/workflow.html","id":"changepoints-rcpp-accelerated-pelt-e-divisive","dir":"Articles","previous_headings":"","what":"Changepoints (Rcpp-accelerated PELT & E-divisive)","title":"End-to-End Wearable Anomaly Workflow","text":"detect_changepoints_pelt() detect_changepoints_edivisive() automatically select Rcpp backend shared library available. can force native path showcase accelerated implementation: packages changepoint {ecp} installed can compare outputs via included parity tests (see Rcpp vignette details).","code":"old_opts <- options(   wearableAnomaly.use_rcpp = TRUE,   wearableAnomaly.rcpp_threshold = 1L ) on.exit(options(old_opts), add = TRUE)  pelt <- detect_changepoints_pelt(ts_5min, penalty = \"MBIC\", min_seg_len = 18) ediv <- detect_changepoints_edivisive(ts_5min, min_seg_len = 18, R = 99)"},{"path":"https://neokok.github.io/wearableAnomaly/articles/workflow.html","id":"merge-and-score-segments","dir":"Articles","previous_headings":"","what":"Merge and score segments","title":"End-to-End Wearable Anomaly Workflow","text":"Artifact detections changepoints can unified via merge_segments(), standardizes schemas groups overlapping episodes. score_anomalies() normalizes contributions per source combines configurable rule:","code":"segments <- merge_segments(   flatlines = flat,   saturation = sat,   ratechange = roc,   pelt = pelt,   edivisive = ediv,   gap = \"10 min\" )  scored <- score_anomalies(segments, combine = \"sum\") scored %>%   select(id, start, end, source, score) %>%   arrange(desc(score)) %>%   head() #> # A tibble: 6 × 5 #>   id    start               end                 source                    score #>   <chr> <dttm>              <dttm>              <chr>                     <dbl> #> 1 id02  2025-01-01 05:15:00 2025-01-01 05:35:00 ratechange|pelt|edivisive  2.09 #> 2 id01  2025-01-01 07:55:00 2025-01-01 07:55:00 pelt|edivisive             1.56 #> 3 id02  2025-01-01 22:10:00 2025-01-01 22:20:00 pelt|edivisive             1.42 #> 4 id02  2025-01-01 13:35:00 2025-01-01 13:35:00 pelt|edivisive             1.37 #> 5 id01  2025-01-01 17:45:00 2025-01-01 17:45:00 pelt|edivisive             1.21 #> 6 id01  2025-01-01 02:20:00 2025-01-01 02:20:00 edivisive                  1"},{"path":"https://neokok.github.io/wearableAnomaly/articles/workflow.html","id":"episode-tables-and-overlay-figure","dir":"Articles","previous_headings":"","what":"Episode tables and overlay figure","title":"End-to-End Wearable Anomaly Workflow","text":"snapshot mirrors tables used final presentation working single subject includes clear detector hits changepoints. Flatline episodes Saturation episodes Rate--change episodes PELT changepoints E-divisive changepoints","code":"set.seed(615) sim_single <- simulate_cgm_benchmark(   n_series = 1,   n_points = 144,   min_seg_len = 12,   n_cps = 3,   seed = 615 ) series <- sim_single$data truth <- sim_single$truth subject <- dplyr::filter(series, id == unique(series$id)) ts_one <- as_wearable_ts(subject, id = id, time = time, value = value) ts_reg <- resample_series(ts_one, by = \"5 min\", agg = \"mean\")  flat_one <- detect_flatlines(ts_reg, min_len = \"15 min\", tol = 2) sat_one <- detect_saturation(ts_reg, min_len = \"15 min\") roc_one <- detect_rate_change(ts_reg, window = \"20 min\", threshold = 3) pelt_one <- detect_changepoints_pelt(ts_reg, penalty = \"MBIC\", min_seg_len = 12) ediv_one <- detect_changepoints_edivisive(ts_reg, min_seg_len = 12, R = 99) knitr::kable(   transmute(flat_one, id, start_time = start, end_time = end,             duration_min = round(as.numeric(end - start, units = \"mins\"), 1),             value = round(value, 1)),   caption = \"Flatline episodes\" ) knitr::kable(   transmute(sat_one, id, start_time = start, end_time = end,             duration_min = round(as.numeric(end - start, units = \"mins\"), 1),             type),   caption = \"Saturation episodes\" ) knitr::kable(   transmute(roc_one, id, start_time = start, end_time = end,             type, strength = round(strength, 2)),   caption = \"Rate-of-change episodes\" ) knitr::kable(   transmute(pelt_one, id, cp_time, new_level = round(new_level, 1),             new_var = round(new_var, 1), penalty),   caption = \"PELT changepoints\" ) knitr::kable(   transmute(ediv_one, id, cp_time, p_value = round(p_value, 3)),   caption = \"E-divisive changepoints\" ) gg <- ggplot(subject, aes(time, value)) +   geom_line(color = \"#2C3E50\") +   labs(x = \"Time\", y = \"Glucose (mg/dL)\",        title = \"Detected artifacts and changepoints on synthetic CGM data\") +   theme_minimal()  if (nrow(flat_one) > 0) {   gg <- gg +     geom_rect(data = flat_one,               aes(xmin = start, xmax = end, ymin = -Inf, ymax = Inf),               inherit.aes = FALSE, alpha = 0.15, fill = \"#F39C12\") }  if (nrow(sat_one) > 0) {   gg <- gg +     geom_rect(data = sat_one,               aes(xmin = start, xmax = end, ymin = -Inf, ymax = Inf, fill = type),               inherit.aes = FALSE, alpha = 0.1) +     scale_fill_manual(values = c(saturation_high = \"#E74C3C\", saturation_low = \"#3498DB\"),                       guide = guide_legend(title = \"Saturation\")) }  if (nrow(roc_one) > 0) {   gg <- gg +     geom_rect(data = roc_one,               aes(xmin = start, xmax = end, ymin = min(subject$value),                   ymax = max(subject$value), fill = type),               inherit.aes = FALSE, alpha = 0.05) +     scale_fill_manual(values = c(roc_up = \"#27AE60\", roc_down = \"#8E44AD\"),                       guide = guide_legend(title = \"Rate change\"),                       breaks = c(\"roc_up\", \"roc_down\")) }  if (nrow(pelt_one) > 0) {   gg <- gg +     geom_vline(data = pelt_one, aes(xintercept = cp_time),                color = \"#C0392B\", linetype = \"dashed\", size = 0.6) } #> Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. #> ℹ Please use `linewidth` instead. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated.  if (nrow(ediv_one) > 0) {   gg <- gg +     geom_vline(data = ediv_one, aes(xintercept = cp_time),                color = \"#2980B9\", linetype = \"dotdash\", size = 0.6) }  gg"},{"path":"https://neokok.github.io/wearableAnomaly/articles/workflow.html","id":"evaluate-against-labeled-truth","dir":"Articles","previous_headings":"","what":"Evaluate against labeled truth","title":"End-to-End Wearable Anomaly Workflow","text":"synthetic generator can embed ground-truth events; human labels deployment, evaluate_methods() computes precision, recall, F1, IoU adjustable tolerance:","code":"metrics <- evaluate_methods(pred = results$segments, truth = labels, tolerance = \"10 min\") metrics"},{"path":"https://neokok.github.io/wearableAnomaly/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Neo Kok. Author, maintainer.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Kok N (2025). wearableAnomaly: Tools Wearable Device Anomaly Detection. R package version 0.0.0.9000.","code":"@Manual{,   title = {wearableAnomaly: Tools for Wearable Device Anomaly Detection},   author = {Neo Kok},   year = {2025},   note = {R package version 0.0.0.9000}, }"},{"path":"https://neokok.github.io/wearableAnomaly/index.html","id":"wearableanomaly","dir":"","previous_headings":"","what":"wearableAnomaly: anomaly detection for wearable time series","title":"wearableAnomaly: anomaly detection for wearable time series","text":"R tooling ingesting continuous glucose monitor (CGM)–style signals, spotting artifacts, flagging changepoints reproducible pipeline.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"wearableAnomaly: anomaly detection for wearable time series","text":"Preprocess & validate: toy_cgm() provides tiny demo series; as_wearable_ts() standardizes <id, time, value> data bounds metadata; validate_ts() resample_series() clean regularize inputs. Artifact detectors: detect_flatlines(), detect_saturation(), detect_rate_change() emit tidy episode tables (start/end/duration/type/strength) common sensor glitches. Changepoints: detect_changepoints_pelt() (mean/variance Poisson costs) detect_changepoints_edivisive() (energy-distance permutations) surface structural shifts. Rcpp backends selected automatically compiled. Pipeline: detect_anomalies() orchestrates validation, optional resampling, detectors, changepoints, merge_segments(), score_anomalies() produce unified table ready benchmarking plotting. evaluate_methods() compares predictions truth labels available.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"wearableAnomaly: anomaly detection for wearable time series","text":"package CRAN. Install development version GitHub whichever helper prefer: ","code":"# install.packages(\"pak\") pak::pak(\"neokok/wearableAnomaly\") install.packages(\"remotes\") remotes::install_github(\"neokok/wearableAnomaly\")"},{"path":"https://neokok.github.io/wearableAnomaly/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick start","title":"wearableAnomaly: anomaly detection for wearable time series","text":"detectors return tibbles, can dplyr::arrange()/plot()/export directly feed evaluation utilities.","code":"library(dplyr) library(wearableAnomaly)  # 1) Simulate one CGM-like subject and coerce to the wa_ts class raw <- toy_cgm(n_id = 1, n = 96, by = \"5 min\", seed = 2025) ts <- as_wearable_ts(raw, id = id, time = time, value = value)  # 2) Optional resampling (already 5 min cadence here, but shown for completeness) ts5 <- resample_series(ts, by = \"5 min\", agg = \"mean\")  # 3) Run artifact and changepoint detectors flat <- detect_flatlines(ts5, min_len = \"20 min\") sat  <- detect_saturation(ts5, min_len = \"15 min\") pelt <- detect_changepoints_pelt(ts5, penalty = \"MBIC\", min_seg_len = 12)  # 4) One-call pipeline with scoring results <- detect_anomalies(ts, preset = \"research\", gap = \"10 min\")  # Peek at merged/scored segments results$segments %>%   select(id, start, end, source, subtype, score) %>%   head()"},{"path":"https://neokok.github.io/wearableAnomaly/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"wearableAnomaly: anomaly detection for wearable time series","text":"Pkgdown site: rebuildable HTML reference docs/. Vignettes: vignettes/workflow.Rmd end--end analysis vignettes/rcpp-comparison.Rmd R vs. Rcpp backend details. Benchmarks: bench/bench_pelt.R contains interactive PELT timing script; expanded benchmark articles (including speed/accuracy tables) live live docs/articles/. GenAI tutorial: Read GenAI workflow tutorial exact prompts, tooling, screenshots, lessons learned building package AI assistance; underlying source lives vignettes/genai-tutorial.Rmd.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/index.html","id":"function-reference-current-exports","dir":"","previous_headings":"","what":"Function reference (current exports)","title":"wearableAnomaly: anomaly detection for wearable time series","text":"detector outputs follow consistent tidy schema, making straightforward merge , compute benchmarks, reproduce “speed & accuracy” tables final presentation.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/index.html","id":"future-work","dir":"","previous_headings":"","what":"Future work","title":"wearableAnomaly: anomaly detection for wearable time series","text":"later exploration (part release): Richer simulators go beyond toy_cgm()/simulate_cgm_benchmark() (e.g., multi-day truth grids). Higher-level summaries anomaly runs reporting dashboards. Additional visualization sugar (e.g., reusable overlay helpers) complement custom ggplot code shown vignette.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"wearableAnomaly: anomaly detection for wearable time series","text":"Issues pull requests welcome. Please open ticket run installation problems ideas additional detectors, simulators, tutorials.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/as_wearable_ts.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce data into a wearable-anomaly time series tibble — as_wearable_ts","title":"Coerce data into a wearable-anomaly time series tibble — as_wearable_ts","text":"Coerce data wearable-anomaly time series tibble","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/as_wearable_ts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce data into a wearable-anomaly time series tibble — as_wearable_ts","text":"","code":"as_wearable_ts(   data,   id,   time,   value,   tz = \"UTC\",   lower = 40,   upper = 400,   cadence = NULL )"},{"path":"https://neokok.github.io/wearableAnomaly/reference/as_wearable_ts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce data into a wearable-anomaly time series tibble — as_wearable_ts","text":"data data frame containing subject identifiers, timestamps, signal values. id, time, value Tidy-select expressions identifying identifier, timestamp, value columns respectively. tz Time zone used coercing time column POSIXct. Defaults \"UTC\". lower, upper Numeric bounds used assessing valid signal values. cadence Optional numeric cadence (seconds) describing expected sampling interval. Stored metadata supplied.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/as_wearable_ts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce data into a wearable-anomaly time series tibble — as_wearable_ts","text":"tibble class wa_ts attributes lower, upper, cadence (stored NA supplied), tz, dups_dropped.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/as_wearable_ts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce data into a wearable-anomaly time series tibble — as_wearable_ts","text":"","code":"data <- toy_cgm(n_id = 2, n = 6) wa <- as_wearable_ts(data, id = id, time = time, value = value) validate_ts(wa) #> # A tibble: 0 × 5 #> # ℹ 5 variables: issue <chr>, id <chr>, time <dttm>, value <dbl>, details <chr>"},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_anomalies.html","id":null,"dir":"Reference","previous_headings":"","what":"High-level anomaly detection pipeline — detect_anomalies","title":"High-level anomaly detection pipeline — detect_anomalies","text":"Runs validation, optional resampling, artifact detectors, changepoint detectors, scoring stages single convenience wrapper.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_anomalies.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"High-level anomaly detection pipeline — detect_anomalies","text":"","code":"detect_anomalies(   x,   preset = c(\"research\", \"clinical\"),   resample_by = \"5 min\",   ... )"},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_anomalies.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"High-level anomaly detection pipeline — detect_anomalies","text":"x wa_ts object data frame coerced via as_wearable_ts(). preset Pipeline preset controlling weighting combination strategy. \"research\" emphasises sensitivity via score summation whereas \"clinical\" emphasises specificity via max pooling. resample_by Optional cadence passed resample_series(). Set NULL skip resampling. ... Additional arguments forwarded merge_segments() score_anomalies() argument names match functions.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_anomalies.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"High-level anomaly detection pipeline — detect_anomalies","text":"list containing merged segments, raw changepoints, raw artifacts, validation issues, (placeholder) plots.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_changepoints_edivisive.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect changepoints with the E-divisive algorithm — detect_changepoints_edivisive","title":"Detect changepoints with the E-divisive algorithm — detect_changepoints_edivisive","text":"Implements univariate version E-divisive procedure based energy distance detect distributional changepoints. Candidate changepoints assessed via permutation test accepted p-value alpha. Detected changepoints investigated recursively left right segments subject minimum segment length constraint.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_changepoints_edivisive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect changepoints with the E-divisive algorithm — detect_changepoints_edivisive","text":"","code":"detect_changepoints_edivisive(x, min_seg_len = 12L, R = 199L, alpha = 0.05)"},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_changepoints_edivisive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect changepoints with the E-divisive algorithm — detect_changepoints_edivisive","text":"x wa_ts tibble produced as_wearable_ts(). min_seg_len Minimum number observations permitted segment. R Number permutations used compute reference distribution. alpha Significance level required accept split (default 0.05).","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_changepoints_edivisive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect changepoints with the E-divisive algorithm — detect_changepoints_edivisive","text":"tibble columns id, cp_time, p_value, method. tibble zero rows changepoints detected.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_changepoints_edivisive.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect changepoints with the E-divisive algorithm — detect_changepoints_edivisive","text":"","code":"set.seed(123) n <- 180 times <- seq.POSIXt(as.POSIXct(\"2025-01-01 00:00:00\", tz = \"UTC\"),   by = \"5 min\", length.out = n ) values <- c(   rnorm(60, 100, 4),   rnorm(60, 120, 6),   rnorm(60, 110, 4) ) ts <- as_wearable_ts(   dplyr::tibble(id = \"id01\", time = times, value = values),   id = id, time = time, value = value ) detect_changepoints_edivisive(ts, min_seg_len = 12, R = 99) #> # A tibble: 2 × 4 #>   id    cp_time             p_value method    #>   <chr> <dttm>                <dbl> <chr>     #> 1 id01  2025-01-01 04:55:00    0.01 edivisive #> 2 id01  2025-01-01 09:50:00    0.01 edivisive"},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_changepoints_pelt.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect changepoints in wearable signals using the PELT algorithm — detect_changepoints_pelt","title":"Detect changepoints in wearable signals using the PELT algorithm — detect_changepoints_pelt","text":"Detect changepoints wearable signals using PELT algorithm","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_changepoints_pelt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect changepoints in wearable signals using the PELT algorithm — detect_changepoints_pelt","text":"","code":"detect_changepoints_pelt(   x,   cost = c(\"meanvar\", \"mean\", \"poisson\"),   penalty = c(\"MBIC\", \"BIC\", \"AIC\"),   min_seg_len = 12L )"},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_changepoints_pelt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect changepoints in wearable signals using the PELT algorithm — detect_changepoints_pelt","text":"x wa_ts tibble produced as_wearable_ts(). cost Cost function optimise. Choose \"meanvar\" (default), \"mean\", \"poisson\". penalty Penalty strategy. Options \"MBIC\", \"BIC\", \"AIC\". min_seg_len Minimum number observations permitted segment.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_changepoints_pelt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect changepoints in wearable signals using the PELT algorithm — detect_changepoints_pelt","text":"tibble detected changepoints containing columns id, cp_time, cp_index, new_level, new_var, method, penalty. Returns zero-row tibble columns changepoints detected.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_changepoints_pelt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect changepoints in wearable signals using the PELT algorithm — detect_changepoints_pelt","text":"","code":"set.seed(123) n <- 240 times <- seq.POSIXt(as.POSIXct(\"2025-01-01 00:00:00\", tz = \"UTC\"),                     by = \"5 min\", length.out = n) values <- c(rnorm(120, mean = 100, sd = 5), rnorm(120, mean = 130, sd = 5)) data <- dplyr::tibble(id = \"id01\", time = times, value = values) ts <- as_wearable_ts(data, id = id, time = time, value = value) detect_changepoints_pelt(ts, cost = \"meanvar\", penalty = \"MBIC\") #> # A tibble: 1 × 7 #>   id    cp_time             cp_index new_level new_var method penalty #>   <chr> <dttm>                 <int>     <dbl>   <dbl> <chr>  <chr>   #> 1 id01  2025-01-01 09:55:00      120      130.    24.2 pelt   MBIC"},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_flatlines.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect flatline segments in a wearable time series — detect_flatlines","title":"Detect flatline segments in a wearable time series — detect_flatlines","text":"Detect flatline segments wearable time series","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_flatlines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect flatline segments in a wearable time series — detect_flatlines","text":"","code":"detect_flatlines(x, tol = 1e-06, min_len = \"15 min\")"},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_flatlines.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect flatline segments in a wearable time series — detect_flatlines","text":"x wa_ts tibble. tol Numeric tolerance used comparing consecutive signal values. min_len Minimum duration (character string understood base::.difftime()) flat segment must span reported.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_flatlines.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect flatline segments in a wearable time series — detect_flatlines","text":"tibble columns id, start, end, duration, type, value, strength. zero-row tibble returned flatlines detected.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_flatlines.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect flatline segments in a wearable time series — detect_flatlines","text":"","code":"data <- toy_cgm(n_id = 1, n = 12) ts <- as_wearable_ts(data, id = id, time = time, value = value) ts$value[4:8] <- 125 detect_flatlines(ts, tol = 1e-5, min_len = \"15 min\") #> # A tibble: 1 × 7 #>   start               end                 duration  type    value strength id    #>   <dttm>              <dttm>              <drtn>    <chr>   <dbl>    <int> <chr> #> 1 2025-01-01 00:15:00 2025-01-01 00:35:00 1200 secs flatli…   125        5 id01"},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_rate_change.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect rate-of-change anomalies in a wearable time series — detect_rate_change","title":"Detect rate-of-change anomalies in a wearable time series — detect_rate_change","text":"Detect rate--change anomalies wearable time series","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_rate_change.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect rate-of-change anomalies in a wearable time series — detect_rate_change","text":"","code":"detect_rate_change(   x,   window = \"15 min\",   threshold = 3,   scale = c(\"mad\", \"sd\", \"none\") )"},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_rate_change.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect rate-of-change anomalies in a wearable time series — detect_rate_change","text":"x wa_ts tibble. window Character string describing maximum separation points used compute rate--change. threshold Numeric threshold applied scaled rate--change. scale Scaling strategy: MAD, standard deviation, \"none\".","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_rate_change.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect rate-of-change anomalies in a wearable time series — detect_rate_change","text":"tibble like detect_flatlines() type values \"roc_up\" \"roc_down\" strength column containing maximum scaled deviation within segment.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_rate_change.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect rate-of-change anomalies in a wearable time series — detect_rate_change","text":"","code":"data <- toy_cgm(n_id = 1, n = 12) ts <- as_wearable_ts(data, id = id, time = time, value = value) ts$value[6] <- ts$value[5] + 60 detect_rate_change(ts, window = \"15 min\", threshold = 3) #> # A tibble: 2 × 7 #>   start               end                 duration type     value strength id    #>   <dttm>              <dttm>              <drtn>   <chr>    <dbl>    <dbl> <chr> #> 1 2025-01-01 00:20:00 2025-01-01 00:25:00 300 secs roc_up     152     5.45 id01  #> 2 2025-01-01 00:25:00 2025-01-01 00:30:00 300 secs roc_down   142     7.27 id01"},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_saturation.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect saturation segments in a wearable time series — detect_saturation","title":"Detect saturation segments in a wearable time series — detect_saturation","text":"Detect saturation segments wearable time series","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_saturation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect saturation segments in a wearable time series — detect_saturation","text":"","code":"detect_saturation(   x,   lower = attr(x, \"lower\"),   upper = attr(x, \"upper\"),   min_len = \"10 min\" )"},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_saturation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect saturation segments in a wearable time series — detect_saturation","text":"x wa_ts tibble. lower, upper Numeric bounds defining saturation thresholds. Defaults metadata carried wa_ts object. min_len Minimum duration (character string) saturation run must span reported.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_saturation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect saturation segments in a wearable time series — detect_saturation","text":"tibble structured like detect_flatlines() type values \"saturation_high\" \"saturation_low\".","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/detect_saturation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect saturation segments in a wearable time series — detect_saturation","text":"","code":"data <- toy_cgm(n_id = 1, n = 12) ts <- as_wearable_ts(data, id = id, time = time, value = value) ts$value[5:9] <- 405 detect_saturation(ts, min_len = \"10 min\") #> # A tibble: 1 × 7 #>   start               end                 duration  type    value strength id    #>   <dttm>              <dttm>              <drtn>    <chr>   <dbl>    <int> <chr> #> 1 2025-01-01 00:20:00 2025-01-01 00:40:00 1200 secs satura…   405        5 id01"},{"path":"https://neokok.github.io/wearableAnomaly/reference/evaluate_methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate predicted anomaly segments — evaluate_methods","title":"Evaluate predicted anomaly segments — evaluate_methods","text":"Computes precision, recall, F1, intersection--union (IoU) predicted vs. reference segments given time tolerance.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/evaluate_methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate predicted anomaly segments — evaluate_methods","text":"","code":"evaluate_methods(   pred,   truth,   tolerance = \"10 min\",   method = NULL,   runtime_sec = NULL )"},{"path":"https://neokok.github.io/wearableAnomaly/reference/evaluate_methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate predicted anomaly segments — evaluate_methods","text":"pred, truth Data frames/tibbles columns id, start, end. pred can also named list prediction objects (see Details). tolerance Allowed temporal slack interpreted base::.difftime(). method Optional label applied pred single data frame. pred list, method labels default list names entry metadata. runtime_sec Optional runtime metadata (seconds) supplied predictions. pred list, runtime metadata can also provided per entry (defaults NA).","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/evaluate_methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate predicted anomaly segments — evaluate_methods","text":"tibble columns method, runtime_sec, mean_n_cps, precision, recall, f1, mae_cp, iou.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/merge_segments.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge heterogeneous anomaly detections — merge_segments","title":"Merge heterogeneous anomaly detections — merge_segments","text":"Standardises outputs artifact detectors, changepoint detectors, anomaly routines common schema merging overlapping segments within subject. merged output includes components list column records contributing detections downstream scoring.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/merge_segments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge heterogeneous anomaly detections — merge_segments","text":"","code":"merge_segments(..., gap = \"5 min\")"},{"path":"https://neokok.github.io/wearableAnomaly/reference/merge_segments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge heterogeneous anomaly detections — merge_segments","text":"... Individual detection results data frames/tibbles single named list. Objects can come directly detect_flatlines(), detect_saturation(), detect_rate_change(), detect_changepoints_pelt(), detect_changepoints_edivisive(). gap Maximum gap tolerated neighbouring detections (per id) collapsed single segment. Can character string understood base::.difftime() numeric number seconds.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/merge_segments.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge heterogeneous anomaly detections — merge_segments","text":"tibble columns id, start, end, source, subtype, score, notes, components. components column stores underlying detections contributing merged segment.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/resample_series.html","id":null,"dir":"Reference","previous_headings":"","what":"Resample a wearable time series onto an even cadence — resample_series","title":"Resample a wearable time series onto an even cadence — resample_series","text":"Resample wearable time series onto even cadence","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/resample_series.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Resample a wearable time series onto an even cadence — resample_series","text":"","code":"resample_series(x, by = \"5 min\", agg = c(\"mean\", \"last\", \"median\"))"},{"path":"https://neokok.github.io/wearableAnomaly/reference/resample_series.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Resample a wearable time series onto an even cadence — resample_series","text":"x wa_ts tibble produced as_wearable_ts(). Character string understood base::seq.POSIXt() defines target sampling cadence (default \"5 min\"). agg Aggregation strategy applied multiple observations fall resampling window. Choose \"mean\", \"last\", \"median\".","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/resample_series.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Resample a wearable time series onto an even cadence — resample_series","text":"wa_ts tibble sampled requested cadence. Metadata attributes lower, upper, cadence, tz, dups_dropped preserved, cadence updated new cadence seconds.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/resample_series.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Resample a wearable time series onto an even cadence — resample_series","text":"","code":"data <- toy_cgm(n_id = 1, n = 8, by = \"7 min\") ts <- as_wearable_ts(data, id = id, time = time, value = value) resampled <- resample_series(ts, by = \"5 min\", agg = \"mean\")"},{"path":"https://neokok.github.io/wearableAnomaly/reference/score_anomalies.html","id":null,"dir":"Reference","previous_headings":"","what":"Score merged anomaly segments — score_anomalies","title":"Score merged anomaly segments — score_anomalies","text":"Normalises scores within detector source combines across sources using requested strategy.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/score_anomalies.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Score merged anomaly segments — score_anomalies","text":"","code":"score_anomalies(segments, weights = NULL, combine = c(\"max\", \"sum\", \"vote\"))"},{"path":"https://neokok.github.io/wearableAnomaly/reference/score_anomalies.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Score merged anomaly segments — score_anomalies","text":"segments Output merge_segments(). weights Optional named numeric vector giving source-specific weights. Unspecified sources default 1. combine Combination strategy: \"max\" (default), \"sum\", \"vote\".","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/score_anomalies.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Score merged anomaly segments — score_anomalies","text":"input tibble score column updated reflect combined score. column raw_score added retain pre-combined values.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/simulate_cgm_benchmark.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate CGM benchmark series with ground-truth changepoints — simulate_cgm_benchmark","title":"Simulate CGM benchmark series with ground-truth changepoints — simulate_cgm_benchmark","text":"Simulate CGM benchmark series ground-truth changepoints","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/simulate_cgm_benchmark.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate CGM benchmark series with ground-truth changepoints — simulate_cgm_benchmark","text":"","code":"simulate_cgm_benchmark(   n_series = 10L,   n_points = 288L,   min_seg_len = 12L,   n_cps = 3L,   seed = NULL,   start_time = as.POSIXct(\"2025-01-01 00:00:00\", tz = \"UTC\"),   dt_minutes = 5 )"},{"path":"https://neokok.github.io/wearableAnomaly/reference/simulate_cgm_benchmark.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate CGM benchmark series with ground-truth changepoints — simulate_cgm_benchmark","text":"n_series Number independent subjects simulate. n_points Number observations per subject (default 288 = 24h 5 minute cadence). min_seg_len Minimum segment length changepoints (samples). n_cps Nominal number changepoints embed per subject. seed Optional integer reproducibility. start_time POSIXct timestamp first observation. dt_minutes Cadence minutes readings.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/simulate_cgm_benchmark.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate CGM benchmark series with ground-truth changepoints — simulate_cgm_benchmark","text":"list two tibbles: data containing columns id, time, value; truth containing id, start, end (changepoint times).","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/simulate_cgm_benchmark.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate CGM benchmark series with ground-truth changepoints — simulate_cgm_benchmark","text":"","code":"sim <- simulate_cgm_benchmark(n_series = 2, n_points = 96, n_cps = 2, seed = 42) names(sim) #> [1] \"data\"  \"truth\""},{"path":"https://neokok.github.io/wearableAnomaly/reference/toy_cgm.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a small synthetic CGM-like data set — toy_cgm","title":"Generate a small synthetic CGM-like data set — toy_cgm","text":"Generate small synthetic CGM-like data set","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/toy_cgm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a small synthetic CGM-like data set — toy_cgm","text":"","code":"toy_cgm(n_id = 2, n = 12, by = \"5 min\", seed = 1)"},{"path":"https://neokok.github.io/wearableAnomaly/reference/toy_cgm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a small synthetic CGM-like data set — toy_cgm","text":"n_id Number unique subjects simulate. n Number observations per subject. Interval passed base::seq.POSIXt() timestamp spacing. seed Optional integer seed reproducible noise.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/toy_cgm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a small synthetic CGM-like data set — toy_cgm","text":"tibble columns id, time, value suitable examples unit tests.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/toy_cgm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a small synthetic CGM-like data set — toy_cgm","text":"","code":"toy_cgm() #> # A tibble: 24 × 3 #>    id    time                value #>    <chr> <dttm>              <dbl> #>  1 id01  2025-01-01 00:00:00   117 #>  2 id01  2025-01-01 00:05:00   128 #>  3 id01  2025-01-01 00:10:00   126 #>  4 id01  2025-01-01 00:15:00   135 #>  5 id01  2025-01-01 00:20:00   122 #>  6 id01  2025-01-01 00:25:00   106 #>  7 id01  2025-01-01 00:30:00   102 #>  8 id01  2025-01-01 00:35:00    96 #>  9 id01  2025-01-01 00:40:00    93 #> 10 id01  2025-01-01 00:45:00    91 #> # ℹ 14 more rows"},{"path":"https://neokok.github.io/wearableAnomaly/reference/validate_ts.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate a wearable-anomaly time series object — validate_ts","title":"Validate a wearable-anomaly time series object — validate_ts","text":"Validate wearable-anomaly time series object","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/validate_ts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate a wearable-anomaly time series object — validate_ts","text":"","code":"validate_ts(x, lower = attr(x, \"lower\"), upper = attr(x, \"upper\"))  has_issues(issues)"},{"path":"https://neokok.github.io/wearableAnomaly/reference/validate_ts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate a wearable-anomaly time series object — validate_ts","text":"x wa_ts object created as_wearable_ts(). lower, upper Numeric bounds used flag --range values. Defaults attributes stored x. issues Output tibble returned validate_ts().","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/validate_ts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate a wearable-anomaly time series object — validate_ts","text":"tibble recording detected issues columns issue, id, time, value, details. zero-row tibble returned issues found.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/validate_ts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Validate a wearable-anomaly time series object — validate_ts","text":"","code":"data <- toy_cgm(n_id = 1, n = 6) ts <- as_wearable_ts(data, id = id, time = time, value = value) validate_ts(ts) #> # A tibble: 0 × 5 #> # ℹ 5 variables: issue <chr>, id <chr>, time <dttm>, value <dbl>, details <chr>"},{"path":"https://neokok.github.io/wearableAnomaly/reference/wearableAnomaly-package.html","id":null,"dir":"Reference","previous_headings":"","what":"wearableAnomaly: Tools for Wearable Device Anomaly Detection — wearableAnomaly-package","title":"wearableAnomaly: Tools for Wearable Device Anomaly Detection — wearableAnomaly-package","text":"package provides helpers ingest, validate, resample, analyse wearable sensor signals ahead anomaly detection workflows.","code":""},{"path":"https://neokok.github.io/wearableAnomaly/reference/wearableAnomaly-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"wearableAnomaly: Tools for Wearable Device Anomaly Detection — wearableAnomaly-package","text":"Maintainer: Neo Kok neokok@umich.edu","code":""}]
