---
title: "End-to-End Wearable Anomaly Workflow"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{End-to-End Wearable Anomaly Workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

`wearableAnomaly` delivers a batch anomaly-detection pipeline for single-sensor
signals such as continuous glucose monitors (CGMs). This vignette walks through
the tidy workflow: ingesting raw observations, validating/resampling, running
artifact and changepoint detectors (with Rcpp acceleration enabled by default),
merging/scoring segments, and evaluating precision/recall against labeled
episodes.

## Getting started

```{r setup}
library(wearableAnomaly)
library(dplyr)
library(ggplot2)
set.seed(20251117)
```

For illustration we generate two synthetic subjects with structured meals and
noise:

```{r data}
raw <- toy_cgm(n_id = 2, n = 240, by = "5 min")
glimpse(raw)
```

## Ingest and validate

`as_wearable_ts()` enforces the `<id, time, value>` schema and stores cadence,
bounds, and timezone metadata. `validate_ts()` reports ordering, duplicates,
and range issues; use `has_issues()` to gate downstream processing.

```{r ingest}
ts <- as_wearable_ts(raw, id = id, time = time, value = value)
issues <- validate_ts(ts)
has_issues(issues)
```

If problems exist they are summarized in `issues`.

## Resample and detect artifacts

Irregularly sampled devices can be regularized with `resample_series()`. The
artifact detectors operate on the resampled tibble:

```{r artifacts}
ts_5min <- resample_series(ts, by = "5 min", agg = "mean")
flat <- detect_flatlines(ts_5min, tol = 2, min_len = "20 min")
sat  <- detect_saturation(ts_5min, min_len = "15 min")
roc  <- detect_rate_change(ts_5min, window = "20 min", threshold = 3)
```

Each detector produces tidy episodes (`id`, `start`, `end`, `type`, `strength`)
and can be plotted or exported independently.

## Changepoints (Rcpp-accelerated PELT & E-divisive)

`detect_changepoints_pelt()` and `detect_changepoints_edivisive()` automatically
select the Rcpp backend when the shared library is available. You can force the
native path to showcase the accelerated implementation:

```{r pelt-ed, message=FALSE}
old_opts <- options(
  wearableAnomaly.use_rcpp = TRUE,
  wearableAnomaly.rcpp_threshold = 1L
)
on.exit(options(old_opts), add = TRUE)

pelt <- detect_changepoints_pelt(ts_5min, penalty = "MBIC", min_seg_len = 18)
ediv <- detect_changepoints_edivisive(ts_5min, min_seg_len = 18, R = 99)
```

When packages such as `{changepoint}` or `{ecp}` are installed you can compare
outputs via the included parity tests (see the Rcpp vignette for details).

## Merge and score segments

Artifact detections and changepoints can be unified via `merge_segments()`,
which standardizes schemas and groups overlapping episodes. `score_anomalies()`
normalizes contributions per source and combines them with a configurable rule:

```{r merge-score}
segments <- merge_segments(
  flatlines = flat,
  saturation = sat,
  ratechange = roc,
  pelt = pelt,
  edivisive = ediv,
  gap = "10 min"
)

scored <- score_anomalies(segments, combine = "sum")
scored %>%
  select(id, start, end, source, score) %>%
  arrange(desc(score)) %>%
  head()
```

## Episode tables and overlay figure

The snapshot below mirrors the tables used in the final presentation by working
with a single subject that includes clear detector hits and changepoints.

```{r example-series}
set.seed(615)
sim_single <- simulate_cgm_benchmark(
  n_series = 1,
  n_points = 144,
  min_seg_len = 12,
  n_cps = 3,
  seed = 615
)
series <- sim_single$data
truth <- sim_single$truth
subject <- dplyr::filter(series, id == unique(series$id))
ts_one <- as_wearable_ts(subject, id = id, time = time, value = value)
ts_reg <- resample_series(ts_one, by = "5 min", agg = "mean")

flat_one <- detect_flatlines(ts_reg, min_len = "15 min", tol = 2)
sat_one <- detect_saturation(ts_reg, min_len = "15 min")
roc_one <- detect_rate_change(ts_reg, window = "20 min", threshold = 3)
pelt_one <- detect_changepoints_pelt(ts_reg, penalty = "MBIC", min_seg_len = 12)
ediv_one <- detect_changepoints_edivisive(ts_reg, min_seg_len = 12, R = 99)
```

```{r episode-tables}
knitr::kable(
  transmute(flat_one, id, start_time = start, end_time = end,
            duration_min = round(as.numeric(end - start, units = "mins"), 1),
            value = round(value, 1)),
  caption = "Flatline episodes"
)

knitr::kable(
  transmute(sat_one, id, start_time = start, end_time = end,
            duration_min = round(as.numeric(end - start, units = "mins"), 1),
            type),
  caption = "Saturation episodes"
)

knitr::kable(
  transmute(roc_one, id, start_time = start, end_time = end,
            type, strength = round(strength, 2)),
  caption = "Rate-of-change episodes"
)

knitr::kable(
  transmute(pelt_one, id, cp_time, new_level = round(new_level, 1),
            new_var = round(new_var, 1), penalty),
  caption = "PELT changepoints"
)

knitr::kable(
  transmute(ediv_one, id, cp_time, p_value = round(p_value, 3)),
  caption = "E-divisive changepoints"
)
```

```{r overlay-plot, fig.width=8, fig.height=4, fig.alt="Overlay plot showing CGM trace with shaded artifact regions and changepoint markers"}
gg <- ggplot(subject, aes(time, value)) +
  geom_line(color = "#2C3E50") +
  labs(x = "Time", y = "Glucose (mg/dL)",
       title = "Detected artifacts and changepoints on synthetic CGM data") +
  theme_minimal()

if (nrow(flat_one) > 0) {
  gg <- gg +
    geom_rect(data = flat_one,
              aes(xmin = start, xmax = end, ymin = -Inf, ymax = Inf),
              inherit.aes = FALSE, alpha = 0.15, fill = "#F39C12")
}

if (nrow(sat_one) > 0) {
  gg <- gg +
    geom_rect(data = sat_one,
              aes(xmin = start, xmax = end, ymin = -Inf, ymax = Inf, fill = type),
              inherit.aes = FALSE, alpha = 0.1) +
    scale_fill_manual(values = c(saturation_high = "#E74C3C", saturation_low = "#3498DB"),
                      guide = guide_legend(title = "Saturation"))
}

if (nrow(roc_one) > 0) {
  gg <- gg +
    geom_rect(data = roc_one,
              aes(xmin = start, xmax = end, ymin = min(subject$value),
                  ymax = max(subject$value), fill = type),
              inherit.aes = FALSE, alpha = 0.05) +
    scale_fill_manual(values = c(roc_up = "#27AE60", roc_down = "#8E44AD"),
                      guide = guide_legend(title = "Rate change"),
                      breaks = c("roc_up", "roc_down"))
}

if (nrow(pelt_one) > 0) {
  gg <- gg +
    geom_vline(data = pelt_one, aes(xintercept = cp_time),
               color = "#C0392B", linetype = "dashed", size = 0.6)
}

if (nrow(ediv_one) > 0) {
  gg <- gg +
    geom_vline(data = ediv_one, aes(xintercept = cp_time),
               color = "#2980B9", linetype = "dotdash", size = 0.6)
}

gg
```

## Evaluate against labeled truth

The synthetic generator can embed ground-truth events; if you have human labels
for a deployment, `evaluate_methods()` computes precision, recall, F1, and IoU
with an adjustable tolerance:

```{r eval, eval=FALSE}
metrics <- evaluate_methods(pred = results$segments, truth = labels, tolerance = "10 min")
metrics
```

